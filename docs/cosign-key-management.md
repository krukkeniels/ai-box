# Cosign Key Management

This document describes the key management procedures for AI-Box image signing
using [Cosign](https://docs.sigstore.dev/cosign/overview/) (Sigstore).

All container images pushed to `harbor.internal` are signed with Cosign.
Developer machines enforce signature verification via Podman's `policy.json`,
rejecting unsigned or incorrectly signed images.

---

## Key Generation Procedure

### Prerequisites

- `cosign` CLI installed ([installation guide](https://docs.sigstore.dev/cosign/installation/))
- A secure workstation with no network-shared filesystem
- Access to the target secret storage system (Vault, CI, or HSM)

### Steps

1. **Generate the key pair** on a trusted workstation:

   ```bash
   cd /tmp/cosign-keygen
   cosign generate-key-pair
   ```

   You will be prompted for a password. Choose a strong password (20+ characters,
   generated by a password manager). This password encrypts the private key at rest.

2. **Record the password** in the same secret store as the private key
   (see Storage Options below).

3. **Verify the key pair** was created:

   ```bash
   ls -la cosign.key cosign.pub
   ```

4. **Store the private key** securely (see next section).

5. **Delete the local private key** after storing it:

   ```bash
   shred -u cosign.key
   ```

6. **Distribute the public key**:
   - Commit `cosign.pub` to the `aibox-images` repository.
   - The `aibox setup` tool (Phase 1) installs it to `/etc/aibox/cosign.pub`.
   - For manual installation, use `infra/cosign/install-policy.sh`.

---

## Private Key Storage Options

### Option 1: CI Secrets (Initial / Simple)

| Attribute | Detail |
|-----------|--------|
| **Mechanism** | Store `cosign.key` contents and `COSIGN_PASSWORD` as CI secret variables |
| **Pros** | Simple setup; no additional infrastructure; works with all CI platforms |
| **Cons** | Secrets are accessible to CI admins; limited audit logging; key is decrypted in memory during signing |
| **Access control** | CI platform's built-in secret scoping (project/group level) |
| **Audit** | CI pipeline logs show when signing occurred; no key-access audit trail |
| **Best for** | Initial deployment, small teams, low-security environments |

**Setup (GitLab CI example)**:

```bash
# Add as CI variables (masked, protected):
#   COSIGN_KEY      = contents of cosign.key
#   COSIGN_PASSWORD = key password
```

### Option 2: HashiCorp Vault (Recommended for Production)

| Attribute | Detail |
|-----------|--------|
| **Mechanism** | Store private key and password in Vault KV secrets engine |
| **Pros** | Centralized secret management; full audit logging; dynamic credentials; access policies |
| **Cons** | Requires Vault infrastructure; adds operational dependency |
| **Access control** | Vault policies restrict access by role/identity |
| **Audit** | Every key access is logged with identity, timestamp, and IP |
| **Best for** | Production environments, regulated industries, teams > 5 |

**Setup**:

```bash
# Store the key
vault kv put secret/aibox/cosign \
  private_key=@cosign.key \
  password="<key-password>"

# Create a policy for CI access
vault policy write aibox-cosign-sign - <<EOF
path "secret/data/aibox/cosign" {
  capabilities = ["read"]
}
EOF

# CI pipeline retrieves the key at signing time
export COSIGN_KEY=$(vault kv get -field=private_key secret/aibox/cosign)
export COSIGN_PASSWORD=$(vault kv get -field=password secret/aibox/cosign)
```

### Option 3: HSM / Cloud KMS (Highest Security)

| Attribute | Detail |
|-----------|--------|
| **Mechanism** | Private key is generated inside and never leaves the HSM/KMS |
| **Pros** | Key material is never exposed; FIPS 140-2 compliant; tamper-resistant |
| **Cons** | Requires HSM hardware or cloud KMS; more complex integration; higher cost |
| **Access control** | HSM/KMS-native access policies |
| **Audit** | HSM/KMS provides tamper-evident audit logs |
| **Best for** | Classified environments, compliance-mandated setups (FedRAMP, FIPS) |

**Setup (AWS KMS example)**:

```bash
# Generate key in KMS (key never leaves KMS)
cosign generate-key-pair --kms awskms:///alias/aibox-cosign

# Sign using KMS (no local key file needed)
cosign sign --key awskms:///alias/aibox-cosign harbor.internal/aibox/base:24.04
```

### Comparison Summary

| Criteria | CI Secrets | Vault | HSM/KMS |
|----------|-----------|-------|---------|
| Setup complexity | Low | Medium | High |
| Operational overhead | Low | Medium | Medium-High |
| Audit trail | Minimal | Full | Full |
| Key exposure risk | Medium | Low | None |
| FIPS compliance | No | Optional | Yes |
| Cost | Free | Vault license | HSM/KMS cost |
| Air-gapped support | Yes | Yes | Depends on HSM |

---

## Key Rotation Procedure

Key rotation should be performed:

- On a **regular schedule** (annually recommended, quarterly for high-security)
- **Immediately** if a key compromise is suspected
- When **personnel with key access** leave the organization

### Step-by-Step Rotation

1. **Generate a new key pair** following the Key Generation Procedure above.
   Use a different output directory to avoid overwriting the current key.

   ```bash
   mkdir /tmp/cosign-rotation
   cd /tmp/cosign-rotation
   cosign generate-key-pair
   ```

2. **Store the new private key** in the same secret store, versioned:

   ```bash
   # Vault example: store as a new version
   vault kv put secret/aibox/cosign \
     private_key=@cosign.key \
     password="<new-password>"
   ```

3. **Update CI pipeline** to use the new key for signing.

4. **Re-sign existing images** that are still in active use:

   ```bash
   # For each actively used image tag:
   cosign sign --key /path/to/new/cosign.key harbor.internal/aibox/base:24.04
   ```

5. **Distribute the new public key** to all developer machines:

   ```bash
   # Update cosign.pub in the repository
   cp /tmp/cosign-rotation/cosign.pub infra/cosign/cosign.pub
   git add infra/cosign/cosign.pub
   git commit -S -m "chore(cosign): rotate signing key $(date +%Y-%m-%d)"

   # Push to developer machines via aibox setup or manual install
   sudo cp infra/cosign/cosign.pub /etc/aibox/cosign.pub
   ```

6. **Verify** that image pulls still work with the new public key:

   ```bash
   ./infra/cosign/verify-image.sh harbor.internal/aibox/base:24.04
   ```

7. **Revoke the old key** (see Emergency Revocation below for procedure).

8. **Clean up** temporary files:

   ```bash
   shred -u /tmp/cosign-rotation/cosign.key
   rm -rf /tmp/cosign-rotation
   ```

### Transition Period

During rotation, there is a brief window where both old and new keys may
be in use. To handle this:

- Sign new images with the **new key only**.
- Keep the old public key available temporarily (rename to `cosign.pub.old`).
- Re-sign critical images with the new key as soon as possible.
- Remove the old public key from developer machines after all active images
  are re-signed.

---

## Access Control

### Who Has Access to What

| Role | Private Key | Public Key | Key Password | Signing Authority |
|------|:-----------:|:----------:|:------------:|:-----------------:|
| Platform team lead | Read | Read | Read | Yes |
| CI pipeline (robot) | Read | Read | Read | Yes (automated) |
| Platform engineers | No | Read | No | No |
| Developers | No | Read | No | No |
| Security team | Audit | Read | Audit | Emergency only |

### Principle of Least Privilege

- The private key should be accessible **only** to the CI pipeline and the
  platform team lead (for emergency manual signing).
- Developers need **only** the public key (for verification).
- All access to the private key should be logged and auditable.

### Secret Store Access Policies

```hcl
# Vault policy: CI pipeline (sign only, read key)
path "secret/data/aibox/cosign" {
  capabilities = ["read"]
}

# Vault policy: Platform team lead (manage key)
path "secret/data/aibox/cosign" {
  capabilities = ["create", "read", "update"]
}

# Vault policy: Security team (audit only)
path "secret/metadata/aibox/cosign" {
  capabilities = ["read", "list"]
}
```

---

## Backup and Recovery Plan

### What to Back Up

| Item | Location | Backup Method |
|------|----------|---------------|
| Private key (`cosign.key`) | Primary secret store | Secondary secret store or encrypted offline backup |
| Key password | Primary secret store | Secondary secret store or sealed envelope |
| Public key (`cosign.pub`) | Git repository | Git history (inherently backed up) |

### Backup Procedures

1. **Primary backup**: The secret store itself (Vault, CI) should have its
   own backup/replication strategy.

2. **Secondary backup**: Create an encrypted offline copy of the private key:

   ```bash
   # Encrypt with GPG for offline storage
   gpg --symmetric --cipher-algo AES256 -o cosign.key.gpg cosign.key

   # Store cosign.key.gpg on encrypted USB drive in a physical safe
   # Record the GPG passphrase separately (split knowledge recommended)
   ```

3. **Public key backup**: The `setup-keys.sh` script creates a timestamped
   backup automatically. The public key is also stored in Git.

### Recovery Procedure

If the primary secret store is unavailable:

1. Retrieve the encrypted offline backup from the physical safe.
2. Decrypt:
   ```bash
   gpg --decrypt cosign.key.gpg > cosign.key
   ```
3. Import into the replacement secret store.
4. Verify signing works:
   ```bash
   cosign sign --key cosign.key harbor.internal/aibox/base:24.04
   ```
5. Shred the decrypted local copy:
   ```bash
   shred -u cosign.key
   ```

If the private key is **permanently lost** (no backup available):

1. Follow the Emergency Key Revocation procedure.
2. Generate a new key pair.
3. Re-sign all active images with the new key.
4. Distribute the new public key to all machines.

---

## Emergency Key Revocation Procedure

Use this procedure if the private key is suspected to be compromised.

### Immediate Actions (within 1 hour)

1. **Disable CI signing**: Remove or rotate the CI secret containing the
   private key to prevent further use.

   ```bash
   # Vault: delete the compromised key
   vault kv delete secret/aibox/cosign
   ```

2. **Notify the team**: Alert all platform engineers and the security team.

3. **Generate a new key pair** immediately:
   ```bash
   cosign generate-key-pair
   ```

4. **Store the new private key** in the secret store.

### Short-Term Actions (within 24 hours)

5. **Re-sign all active images** with the new key:

   ```bash
   # List all active image tags from Harbor
   # For each tag:
   cosign sign --key /path/to/new/cosign.key harbor.internal/aibox/<image>:<tag>
   ```

6. **Distribute the new public key** to all developer machines:

   ```bash
   # Update repository
   cp cosign.pub infra/cosign/cosign.pub
   git commit -S -m "security(cosign): emergency key rotation - key compromised"

   # Force-push to developer machines
   sudo cp cosign.pub /etc/aibox/cosign.pub
   ```

7. **Verify** all developer machines can pull images with the new key.

### Follow-Up Actions (within 1 week)

8. **Audit signing logs**: Review CI pipeline logs to identify any images
   signed between the suspected compromise time and key revocation.

9. **Investigate compromise**: Determine how the key was compromised and
   address the root cause.

10. **Document the incident**: Record timeline, actions taken, and
    preventive measures in the incident log.

11. **Review access controls**: Tighten permissions if the compromise
    resulted from overly broad access.

---

## Audit Trail Requirements

### What Must Be Logged

| Event | Required Fields | Retention |
|-------|----------------|-----------|
| Key generation | Who, when, where, key fingerprint | Permanent |
| Key access (read) | Who, when, source IP, purpose | 1 year minimum |
| Image signing | Image ref, key fingerprint, timestamp, pipeline ID | 1 year minimum |
| Key rotation | Old key fingerprint, new key fingerprint, who, when | Permanent |
| Key revocation | Who, when, reason, incident ID | Permanent |
| Public key distribution | Target machine, who, when | 6 months |

### How to Audit

- **Vault**: Enable audit logging (`vault audit enable file file_path=/var/log/vault/audit.log`).
  All key access events are automatically recorded.

- **CI pipeline**: Signing steps should log the image reference and a
  non-sensitive key identifier (fingerprint, not the key itself).

- **Cosign verification**: Use `cosign verify` output which includes
  signature metadata and timestamps.

### Periodic Review

- **Monthly**: Review signing logs for anomalies (unexpected signing times,
  unknown pipeline IDs).
- **Quarterly**: Review access control list -- ensure only authorized
  roles have key access.
- **Annually**: Full key management procedure review. Consider rotation
  even if no incident has occurred.
