package siem

import (
	"fmt"
	"strings"
)

// SinkType identifies the SIEM integration method.
type SinkType string

const (
	SinkSyslog SinkType = "syslog"
	SinkHTTP   SinkType = "http"
	SinkS3     SinkType = "s3"
	SinkKafka  SinkType = "kafka"
)

// SinkConfig holds the configuration for a Vector SIEM sink.
type SinkConfig struct {
	Type     SinkType // syslog, http, s3, kafka
	Endpoint string   // target endpoint
	Format   string   // cef, leef, json, syslog_rfc5424 (default: json)
	TLS      bool     // enable TLS
	AuthType string   // none, basic, bearer, api_key (default: none)
}

// DefaultSinkConfig returns a SinkConfig with sensible defaults.
func DefaultSinkConfig() SinkConfig {
	return SinkConfig{
		Type:     SinkHTTP,
		Format:   "json",
		TLS:      true,
		AuthType: "none",
	}
}

// GenerateVectorSink produces the Vector TOML sink configuration for SIEM integration.
func GenerateVectorSink(cfg SinkConfig) string {
	var b strings.Builder

	b.WriteString("# =============================================================================\n")
	b.WriteString("# AI-Box SIEM Integration Sink\n")
	b.WriteString("# Generated by aibox â€” DO NOT EDIT MANUALLY\n")
	b.WriteString("# =============================================================================\n\n")

	switch cfg.Type {
	case SinkSyslog:
		generateSyslogSink(&b, cfg)
	case SinkHTTP:
		generateHTTPSink(&b, cfg)
	case SinkS3:
		generateS3Sink(&b, cfg)
	case SinkKafka:
		generateKafkaSink(&b, cfg)
	default:
		generateHTTPSink(&b, cfg)
	}

	return b.String()
}

func generateSyslogSink(b *strings.Builder, cfg SinkConfig) {
	b.WriteString("[sinks.siem]\n")
	b.WriteString("  type = \"socket\"\n")
	b.WriteString("  inputs = [\"parse_audit\", \"parse_squid\", \"parse_decisions\", \"enrich_journald\"]\n")
	b.WriteString("  mode = \"tcp\"\n")
	fmt.Fprintf(b, "  address = %q\n", cfg.Endpoint)
	b.WriteString("  encoding.codec = \"json\"\n")
	if cfg.TLS {
		b.WriteString("  tls.enabled = true\n")
	}
}

func generateHTTPSink(b *strings.Builder, cfg SinkConfig) {
	b.WriteString("[sinks.siem]\n")
	b.WriteString("  type = \"http\"\n")
	b.WriteString("  inputs = [\"parse_audit\", \"parse_squid\", \"parse_decisions\", \"enrich_journald\"]\n")
	b.WriteString("  method = \"post\"\n")
	fmt.Fprintf(b, "  uri = %q\n", cfg.Endpoint)
	fmt.Fprintf(b, "  encoding.codec = %q\n", cfg.Format)
	if cfg.TLS {
		b.WriteString("  tls.verify_certificate = true\n")
	}
	b.WriteString("\n")
	b.WriteString("  # Retry and buffer for at-least-once delivery\n")
	b.WriteString("  [sinks.siem.buffer]\n")
	b.WriteString("    type = \"disk\"\n")
	b.WriteString("    max_size = 524288000\n") // 500 MB
	b.WriteString("    when_full = \"block\"\n")
	b.WriteString("\n")
	b.WriteString("  [sinks.siem.request]\n")
	b.WriteString("    retry_max_duration_secs = 3600\n")
	b.WriteString("    rate_limit_num = 100\n")
}

func generateS3Sink(b *strings.Builder, cfg SinkConfig) {
	b.WriteString("[sinks.siem]\n")
	b.WriteString("  type = \"aws_s3\"\n")
	b.WriteString("  inputs = [\"parse_audit\", \"parse_squid\", \"parse_decisions\", \"enrich_journald\"]\n")
	if cfg.Endpoint != "" {
		fmt.Fprintf(b, "  endpoint = %q\n", cfg.Endpoint)
	}
	b.WriteString("  bucket = \"aibox-siem\"\n")
	b.WriteString("  key_prefix = \"aibox-events/%Y/%m/%d/\"\n")
	fmt.Fprintf(b, "  encoding.codec = %q\n", cfg.Format)
	b.WriteString("  compression = \"gzip\"\n")
	b.WriteString("\n")
	b.WriteString("  [sinks.siem.buffer]\n")
	b.WriteString("    type = \"disk\"\n")
	b.WriteString("    max_size = 524288000\n")
	b.WriteString("    when_full = \"block\"\n")
}

func generateKafkaSink(b *strings.Builder, cfg SinkConfig) {
	b.WriteString("[sinks.siem]\n")
	b.WriteString("  type = \"kafka\"\n")
	b.WriteString("  inputs = [\"parse_audit\", \"parse_squid\", \"parse_decisions\", \"enrich_journald\"]\n")
	fmt.Fprintf(b, "  bootstrap_servers = %q\n", cfg.Endpoint)
	b.WriteString("  topic = \"aibox-audit-events\"\n")
	fmt.Fprintf(b, "  encoding.codec = %q\n", cfg.Format)
	if cfg.TLS {
		b.WriteString("  tls.enabled = true\n")
	}
	b.WriteString("\n")
	b.WriteString("  [sinks.siem.buffer]\n")
	b.WriteString("    type = \"disk\"\n")
	b.WriteString("    max_size = 524288000\n")
	b.WriteString("    when_full = \"block\"\n")
}
