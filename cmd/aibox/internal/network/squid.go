package network

import (
	"fmt"
	"log/slog"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// DefaultAllowedDomains is the base set of domains that AI-Box containers can reach.
var DefaultAllowedDomains = []string{
	"harbor.internal",  // Container image registry
	"nexus.internal",   // Package mirrors (npm, Maven, PyPI, NuGet, Go, Cargo)
	"foundry.internal", // LLM API gateway
	"git.internal",     // Source repos and policy repo
	"vault.internal",   // Credential management and secret storage
}

// SquidConfig holds the configuration for the Squid proxy.
type SquidConfig struct {
	ListenAddr     string   // default "127.0.0.1"
	ListenPort     int      // default 3128
	AllowedDomains []string // domains to allow through proxy
	LogPath        string   // default "/var/log/aibox/proxy-access.log"
	ConfigPath     string   // default "/etc/aibox/squid.conf"
}

// SquidManager manages Squid proxy configuration and lifecycle.
type SquidManager struct {
	cfg SquidConfig
}

// DefaultSquidConfig returns a SquidConfig with sensible defaults.
func DefaultSquidConfig() SquidConfig {
	return SquidConfig{
		ListenAddr:     "127.0.0.1",
		ListenPort:     3128,
		AllowedDomains: DefaultAllowedDomains,
		LogPath:        "/var/log/aibox/proxy-access.log",
		ConfigPath:     "/etc/aibox/squid.conf",
	}
}

// NewSquidManager creates a SquidManager, applying defaults for any zero-value fields.
func NewSquidManager(cfg SquidConfig) *SquidManager {
	if cfg.ListenAddr == "" {
		cfg.ListenAddr = "127.0.0.1"
	}
	if cfg.ListenPort == 0 {
		cfg.ListenPort = 3128
	}
	if len(cfg.AllowedDomains) == 0 {
		cfg.AllowedDomains = DefaultAllowedDomains
	}
	if cfg.LogPath == "" {
		cfg.LogPath = "/var/log/aibox/proxy-access.log"
	}
	if cfg.ConfigPath == "" {
		cfg.ConfigPath = "/etc/aibox/squid.conf"
	}
	return &SquidManager{cfg: cfg}
}

// Config returns the current SquidConfig (read-only copy).
func (m *SquidManager) Config() SquidConfig {
	return m.cfg
}

// GenerateConfig produces a complete squid.conf with security-hardened defaults.
func (m *SquidManager) GenerateConfig() string {
	var b strings.Builder

	b.WriteString("# =============================================================================\n")
	b.WriteString("# AI-Box Squid Proxy Configuration\n")
	b.WriteString("# Generated by aibox — DO NOT EDIT MANUALLY\n")
	b.WriteString("#\n")
	b.WriteString("# This proxy enforces a default-deny egress policy. Only traffic to explicitly\n")
	b.WriteString("# allowed internal domains is permitted. All other outbound connections are\n")
	b.WriteString("# blocked, including HTTPS via SNI inspection.\n")
	b.WriteString("# =============================================================================\n\n")

	// --- Listener ---
	b.WriteString("# ---- Listener ----------------------------------------------------------------\n")
	b.WriteString("# Bind to localhost only. Containers reach the proxy through the host network\n")
	b.WriteString("# namespace via the container gateway address. Binding to 127.0.0.1 prevents\n")
	b.WriteString("# any external host from using this proxy.\n")
	fmt.Fprintf(&b, "http_port %s:%d\n\n", m.cfg.ListenAddr, m.cfg.ListenPort)

	// --- Identity ---
	b.WriteString("# ---- Identity ----------------------------------------------------------------\n")
	b.WriteString("visible_hostname aibox-proxy\n\n")

	// --- ACLs: allowed domains ---
	b.WriteString("# ---- ACLs: allowed domains ----------------------------------------------------\n")
	b.WriteString("# Each domain is listed with a leading dot to also match subdomains.\n")
	b.WriteString("# For example, .harbor.internal matches harbor.internal AND\n")
	b.WriteString("# registry.harbor.internal.\n")
	for _, domain := range m.cfg.AllowedDomains {
		fmt.Fprintf(&b, "acl aibox_allowed dstdomain .%s\n", domain)
	}
	b.WriteString("\n")

	// --- ACLs: port safety ---
	b.WriteString("# ---- ACLs: port safety --------------------------------------------------------\n")
	b.WriteString("# Only allow traffic to standard HTTP/HTTPS ports. This blocks attempts to\n")
	b.WriteString("# tunnel arbitrary protocols through the proxy on non-standard ports.\n")
	b.WriteString("acl Safe_ports port 80\n")
	b.WriteString("acl Safe_ports port 443\n")
	b.WriteString("acl SSL_ports port 443\n\n")

	// --- ACL: CONNECT method ---
	b.WriteString("# ---- ACL: CONNECT method ------------------------------------------------------\n")
	b.WriteString("acl CONNECT method CONNECT\n\n")

	// --- Access rules ---
	b.WriteString("# ---- Access rules (order matters!) --------------------------------------------\n")
	b.WriteString("# 1. Block requests to non-standard ports immediately.\n")
	b.WriteString("http_access deny !Safe_ports\n\n")
	b.WriteString("# 2. Block CONNECT (tunneling) to non-SSL ports.\n")
	b.WriteString("http_access deny CONNECT !SSL_ports\n\n")
	b.WriteString("# 3. Allow CONNECT tunnels to permitted domains (HTTPS).\n")
	b.WriteString("http_access allow CONNECT aibox_allowed\n\n")
	b.WriteString("# 4. Allow plain HTTP to permitted domains.\n")
	b.WriteString("http_access allow aibox_allowed\n\n")
	b.WriteString("# 5. DEFAULT DENY — block everything not explicitly allowed above.\n")
	b.WriteString("# This is the most important rule. Without it, Squid's default behaviour\n")
	b.WriteString("# would allow traffic to pass.\n")
	b.WriteString("http_access deny all\n\n")

	// --- SNI-based HTTPS filtering ---
	b.WriteString("# ---- SNI-based HTTPS filtering ------------------------------------------------\n")
	b.WriteString("# Use ssl_bump in peek-and-splice mode. This inspects the TLS ClientHello SNI\n")
	b.WriteString("# to determine the target domain WITHOUT decrypting traffic (no MITM).\n")
	b.WriteString("# - peek: read the SNI from the ClientHello\n")
	b.WriteString("# - splice: forward the TLS connection as-is to allowed domains\n")
	b.WriteString("# Access control is enforced by the http_access rules above; denied domains\n")
	b.WriteString("# never reach the splice step because the CONNECT is rejected.\n")
	b.WriteString("ssl_bump peek all\n")
	b.WriteString("ssl_bump splice all\n\n")

	// --- Caching: disabled ---
	b.WriteString("# ---- Caching: disabled --------------------------------------------------------\n")
	b.WriteString("# AI-Box uses Nexus as a caching registry/mirror. The proxy's only job is\n")
	b.WriteString("# access control, not caching, so we disable it entirely.\n")
	b.WriteString("cache deny all\n")
	b.WriteString("maximum_object_size 0 KB\n\n")

	// --- Logging ---
	b.WriteString("# ---- Logging -----------------------------------------------------------------\n")
	b.WriteString("# Structured access log with timestamp, source IP, destination, HTTP method,\n")
	b.WriteString("# status code, and bytes transferred. This feeds into the audit pipeline.\n")
	fmt.Fprintf(&b, "access_log daemon:%s logformat=squid\n", m.cfg.LogPath)
	b.WriteString("logformat squid %ts.%03tu %6tr %>a %Ss/%03>Hs %<st %rm %ru %un %Sh/%<a %mt\n\n")

	// --- Runtime ---
	b.WriteString("# ---- Runtime -----------------------------------------------------------------\n")
	b.WriteString("coredump_dir /var/spool/squid\n")

	return b.String()
}

// WriteConfig writes the generated Squid configuration to the specified path.
// Parent directories are created if they do not exist.
func (m *SquidManager) WriteConfig(path string) error {
	if path == "" {
		path = m.cfg.ConfigPath
	}

	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("creating config directory %s: %w", dir, err)
	}

	content := m.GenerateConfig()
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("writing squid config to %s: %w", path, err)
	}

	slog.Info("wrote squid config", "path", path, "domains", len(m.cfg.AllowedDomains))
	return nil
}

// IsRunning checks whether Squid is listening on the configured address and port.
func (m *SquidManager) IsRunning() bool {
	addr := fmt.Sprintf("%s:%d", m.cfg.ListenAddr, m.cfg.ListenPort)
	conn, err := net.DialTimeout("tcp", addr, 2*time.Second)
	if err != nil {
		return false
	}
	conn.Close()
	return true
}

// HealthCheck verifies that Squid is running and accepting TCP connections.
func (m *SquidManager) HealthCheck() error {
	addr := fmt.Sprintf("%s:%d", m.cfg.ListenAddr, m.cfg.ListenPort)
	conn, err := net.DialTimeout("tcp", addr, 3*time.Second)
	if err != nil {
		return fmt.Errorf("squid health check failed (cannot connect to %s): %w", addr, err)
	}
	conn.Close()
	slog.Debug("squid health check passed", "addr", addr)
	return nil
}

// Start launches the Squid proxy. It first tries systemctl, then falls back to
// running squid directly with the configured config file.
func (m *SquidManager) Start() error {
	if m.IsRunning() {
		slog.Info("squid is already running", "addr", m.cfg.ListenAddr, "port", m.cfg.ListenPort)
		return nil
	}

	// Try systemctl first (works on systemd-managed hosts).
	if path, err := exec.LookPath("systemctl"); err == nil {
		slog.Debug("starting squid via systemctl", "path", path)
		cmd := exec.Command(path, "start", "squid")
		if out, err := cmd.CombinedOutput(); err != nil {
			slog.Warn("systemctl start squid failed, trying direct invocation", "error", err, "output", string(out))
		} else {
			slog.Info("squid started via systemctl")
			return nil
		}
	}

	// Fall back to direct invocation.
	squidPath, err := exec.LookPath("squid")
	if err != nil {
		return fmt.Errorf("squid binary not found in PATH: %w", err)
	}

	slog.Debug("starting squid directly", "binary", squidPath, "config", m.cfg.ConfigPath)
	cmd := exec.Command(squidPath, "-f", m.cfg.ConfigPath)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to start squid: %s\n%s", err, string(out))
	}

	slog.Info("squid started", "config", m.cfg.ConfigPath)
	return nil
}

// Stop shuts down the Squid proxy.
func (m *SquidManager) Stop() error {
	// Try systemctl first.
	if path, err := exec.LookPath("systemctl"); err == nil {
		slog.Debug("stopping squid via systemctl")
		cmd := exec.Command(path, "stop", "squid")
		if out, err := cmd.CombinedOutput(); err != nil {
			slog.Warn("systemctl stop squid failed, trying squid -k shutdown", "error", err, "output", string(out))
		} else {
			slog.Info("squid stopped via systemctl")
			return nil
		}
	}

	// Fall back to squid -k shutdown.
	squidPath, err := exec.LookPath("squid")
	if err != nil {
		return fmt.Errorf("squid binary not found in PATH: %w", err)
	}

	cmd := exec.Command(squidPath, "-k", "shutdown", "-f", m.cfg.ConfigPath)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to stop squid: %s\n%s", err, string(out))
	}

	slog.Info("squid stopped")
	return nil
}

// Reload tells a running Squid to re-read its configuration file without
// dropping active connections.
func (m *SquidManager) Reload() error {
	squidPath, err := exec.LookPath("squid")
	if err != nil {
		return fmt.Errorf("squid binary not found in PATH: %w", err)
	}

	slog.Debug("reconfiguring squid", "config", m.cfg.ConfigPath)
	cmd := exec.Command(squidPath, "-k", "reconfigure", "-f", m.cfg.ConfigPath)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to reload squid config: %s\n%s", err, string(out))
	}

	slog.Info("squid configuration reloaded")
	return nil
}

// Install installs the Squid package using the system package manager.
func (m *SquidManager) Install() error {
	aptPath, err := exec.LookPath("apt-get")
	if err != nil {
		return fmt.Errorf("apt-get not found: only Debian/Ubuntu systems are supported: %w", err)
	}

	slog.Info("installing squid via apt-get")
	cmd := exec.Command(aptPath, "install", "-y", "squid")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to install squid: %w", err)
	}

	slog.Info("squid installed successfully")
	return nil
}
